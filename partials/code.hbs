<ul>
    <li><a href="#data-structures">Data Structures</a></li>
    <li><a href="#search-algorithms">Search Algorithms</a></li>
    <li><a href="#sorting-algorithms">Sorting Algorithms</a></li>
    <li><a href="#big-o">Big-O</a></li>
    <li><a href="#programming">Programming</a></li>
    <li><a href="#design-patterns">Design Patterns</a></li>
    <li><a href="#misc">Miscellaneous</a></li>
    <li><a href="#good-sites">Good Sites</a></li>
</ul>
<span id="data-structures">Data Structures</span>
<ul class="code-list">
    <li><a id="linked-list" class="code-item" onclick="codeItemClicked(this);">+</a>Linked List
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Like arrays, Linked List is a linear data structure. Unlike arrays, linked list elements are not stored at contiguous location; the elements are linked using pointers.</p>
            <p><img src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist.png" alt="Linked List"/></p>
            <h3>Advantages</h3>
            <ul>
                <li>Dynamic size</li>
                <li>Ease of insertion/deletion</li>
            </ul>
            <h3>Disadvantages</h3>
            <ul>
                <li>Random access is not allowed. We have to access elements sequentially starting from the first node. So we cannot do binary search with linked lists.</li>
                <li>Extra memory space for a pointer is required with each element of the list.</li>
            </ul>
            <h3>More Information</h3>
            <p><a href="http://www.geeksforgeeks.org/data-structures/linked-list/">Geeks for Geeks</a></p>
        </div>
    </li>
    <li><a id="stack" class="code-item" onclick="codeItemClicked(this);">+</a>Stack
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Stack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out).</p>
            <p>Mainly the following three basic operations are performed in the stack:</p>
            <p><img src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/stack.png" alt="Stack"/></p>
            <ul>
                <li><span style="font-weight:bold;">Push</span>: Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition.</li>
                <li><span style="font-weight:bold;">Pop</span>: Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.</li>
                <li><span style="font-weight:bold;">Peek or Top</span>: Returns top element of stack.</li>
                <li><span style="font-weight:bold;">isEmpty</span>: Returns true if stack is empty, else fals.</li>
            </ul>
            <h3>Time Complexities</h3>
            <p>Time Complexities of operations on stack:</p>
            <p>p>push(), pop(), esEmpty() and peek() all take O(1) time. We do not run any loop in any of these operations.</p>
            <h3>More Informaiton</h3>
            <p><a href="http://www.geeksforgeeks.org/stack/">Geeks for Geeks</a></p>
        </div></li>
    <li><a id="queue" class="code-item" onclick="codeItemClicked(this);">+</a>Queue
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Like Stack, Queue is a linear structure which follows a particular order in which the operations are performed. The order is First In First Out (FIFO).  A good example of queue is any queue of consumers for a resource where the consumer that came first is served first.</p>
            <p>The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.</p>
            <p>Mainly the following four basic operations are performed on queue:</p>
            <ul>
            <li><span style="font-weight:bold;">Enqueue</span>: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.</li>
            <li><span style="font-weight:bold;">Dequeue</span>: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition.</li>
            <li><span style="font-weight:bold;">Front</span>: Get the front item from queue.</li>
            <li><span style="font-weight:bold;">Rear</span>: Get the last item from queue.</li>
            </ul>
            <p><img src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/02/Queue.png" alt="queue"/></p>
            <h3>More Info</h3>
            <p><a href="http://www.geeksforgeeks.org/queue/">Geeks for Geeks</a></p>
        </div></li>
    <li><a id="priority-queue" class="code-item" onclick="codeItemClicked(this);">*</a>Priority Queue
        <div class="in-detail">
            <h3>Overview</h3>
            <p>a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a "priority" associated with it. In a priority queue, an element with high priority is served before an element with low priority.</p>
        </div>
    </li>
    <li><a id="binary-tree" class="code-item" onclick="codeItemClicked(this);">+</a>Binary Tree
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures. A Binary Tree is a tree whose elements have at most 2 children is called a binary tree. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.</p>
            <h3>Vocabulary</h3>
            <p>The topmost node is called root of the tree. The elements that are directly under an element are called its children. The element directly above something is called its parent. For example, a is a child of f and f is the parent of a. Finally, elements with no children are called leaves.</p>
            <h3>Why Trees</h3>
            <ul>
                <li>One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer</li>
                <li>Trees (with some ordering e.g., BST) provide moderate access/search (quicker than Linked List and slower than arrays).</li>
                <li>Trees provide moderate insertion/deletion (quicker than Arrays and slower than Unordered Linked Lists).</li>
                <li>Like Linked Lists and unlike Arrays, Trees don’t have an upper limit on number of nodes as nodes are linked using pointers.</li>
            </ul>
            <h3>Types</h3>
            <ul>
                <li>Full: A Binary Tree is full if every node has 0 or 2 children</li>
                <li>Complete Binary Tree: A Binary Tree is complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possible</li>
                <li>Perfect Binary Tree A Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at same level.</li>
                <li>A binary tree is balanced if height of the tree is O(Log n) where n is number of nodes. For Example, AVL tree maintain O(Log n) height by making sure that the difference between heights of left and right subtrees is 1. Red-Black trees maintain O(Log n) height by making sure that the number of Black nodes on every root to leaf paths are same and there are no adjacent red nodes. Balanced Binary Search trees are performance wise good as they provide O(log n) time for search, insert and delete.</li>
                <li>A degenerate (or pathological) tree A Tree where every internal node has one child. Such trees are performance-wise same as linked list.</li>
            </ul>
            <p><img src="http://geeksforgeeks.org/wp-content/uploads/2009/06/tree12.gif"/></p>
            <h3>Depth First Traversal</h3>
            <ul>
                <li>Inorder (Left, Root, Right) : 4 2 5 1 3</li>
                <li>Preorder (Root, Left, Right) : 1 2 4 5 3</li>
                <li>Postorder (Left, Right, Root) : 4 5 2 3 1</li>
            </ul>
            <h3>Breadth First Traversal</h3>
            <ul>
                <li>Breadth First or Level Order Traversal : 1 2 3 4 5</li>
            </ul>
            <h3>More Info</h3>
            <p><a href="http://www.geeksforgeeks.org/binary-tree-2/">Geeks for Geeks</a></p>
        </div></li>
    <li><a id="binary-search-tree" class="code-item" onclick="codeItemClicked(this);">+</a>Binary Search Tree
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Binary Search Tree, is a node-based binary tree data structure which has the following properties:</p>
            <ul>
                <li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
                <li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
                <li>The left and right subtree each must also be a binary search tree.</li>
                <li>There must be no duplicate nodes.</li>
            </ul>
            <p><img src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/200px-Binary_search_tree.svg_.png"/>></p>
            <h3>Time Complexity</h3>
            <p>The worst case time complexity of search and insert operations is O(h) where h is height of Binary Search Tree. In worst case, we may have to travel from root to the deepest leaf node. The height of a skewed tree may become n and the time complexity of search and insert operation may become O(n).</p>
            <h3>More Info</h3>
            <p><a href="http://www.geeksforgeeks.org/binary-search-tree/">Geeks for Geeks</a></p>
        </div></li>
    <li><a id="binary-heap" class="code-item" onclick="codeItemClicked(this);">+</a>Binary Heap
        <div class="in-detail">
            <h3>Overview</h3>
            <p>A Binary Heap is a Binary Tree with following properties.</p>
            <ul>
                <li>It’s a complete tree (All levels are completely filled except possibly the last level and the last level has all keys as left as possible). This property of Binary Heap makes them suitable to be stored in an array.</li>
                <li>A Binary Heap is either Min Heap or Max Heap. In a Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap. The same property must be recursively true for all nodes in Binary Tree. Max Binary Heap is similar to Min Heap.</li>
            </ul>
            <h3>Operations and Time Complexity</h3>
            <ul>
                <li>getMini(): It returns the root element of Min Heap. Time Complexity of this operation is O(1).</li>
                <li>extractMin(): Removes the minimum element from Min Heap. Time Complexity of this Operation is O(Logn) as this operation needs to maintain the heap property (by calling heapify()) after removing root.</li>
                <li>decreaseKey(): Decreases value of key. Time complexity of this operation is O(Logn). If the decreases key value of a node is greater than parent of the node, then we don’t need to do anything. Otherwise, we need to traverse up to fix the violated heap property.</li>
                <li>insert(): Inserting a new key takes O(Logn) time. We add a new key at the end of the tree. IF new key is greater than its parent, then we don’t need to do anything. Otherwise, we need to traverse up to fix the violated heap property.</li>
                <li>delete(): Deleting a key also takes O(Logn) time. We replace the key to be deleted with minum infinite by calling decreaseKey(). After decreaseKey(), the minus infinite value must reach root, so we call extractMin() to remove key.</li>
            </ul>
            <h3>More Info</h3>
            <p><a href="http://www.geeksforgeeks.org/heap/">Geeks for Geeks</a></p>
        </div></li>
    <li><a id="hashing" class="code-item" onclick="codeItemClicked(this);">+</a>Hashing
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Hashing is an improvement over Direct Access Table. The idea is to use hash function that converts a given phone number or any other key to a smaller number and uses the small number as index in a table called hash table. A direct access table is where we make a big array and use numbers as index in the array.
            The problem with direct access tables is that the numbers can be quite large, and we can't use anything other than a number. The solution is to use hashing.</p>
            <h3>Hash Function</h3>
            <p>Hash Function: A function that converts a given big phone number to a small practical integer value. The mapped integer value is used as an index in hash table. In simple terms, a hash function maps a big number or string to a small integer that can be used as index in hash table.
                A good hash function should have following properties 1) Efficiently computable. 2) Should uniformly distribute the keys (Each table position equally likely for each key)</p>
            <h3>Hash Table</h3>
            <p>An array that stores pointers to records corresponding to a given hashed key. An entry in hash table is NIL if no existing key has hash function value equal to the index for the entry.</p>
            <h3>Collisions</h3>
            <p>One potential problem is that thre are multiple entries for a hash key value. One method to solve this is to make the entry in the array an array itself and iterate through that array to find the element.</p>
            <h3>More Info</h3>
            <p><a href="http://www.geeksforgeeks.org/hashing/">Geeks for Geeks</a></p>
        </div></li>
    <li><a id="graph" class="code-item" onclick="codeItemClicked(this);">+</a>Graph
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Graph is a data structure that consists of following two components:</p>
            <ul>
                <li>A finite set of vertices also called as nodes.</li>
                <li>A finite set of ordered pair of the form (u, v) called as edge. The pair is ordered because (u, v) is not same as (v, u) in case of directed graph(di-graph). The pair of form (u, v) indicates that there is an edge from vertex u to vertex v. The edges may contain weight/value/cost.</li>
            </ul>
            <h3>Example Uses</h3>
            <p>Graphs are used to represent many real life applications: Graphs are used to represent networks. The networks may include paths in a city or telephone network or circuit network. Graphs are also used in social networks like linkedIn, facebook. For example, in facebook, each person is represented with a vertex(or node). Each node is a structure and contains information like person id, name, gender and locale. See this for more applications of graph.</p>
            <h3>Example Graph</h3>
            <p><img src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/graph_representation12.png"/></p>
            <h3>Adjancency Matrix</h3>
            <p>Adjacency Matrix is a 2D array of size V x V where V is the number of vertices in a graph. Let the 2D array be adj[][], a slot adj[i][j] = 1 indicates that there is an edge from vertex i to vertex j. Adjacency matrix for undirected graph is always symmetric. Adjacency Matrix is also used to represent weighted graphs. If adj[i][j] = w, then there is an edge from vertex i to vertex j with weight w.</p>
            <p>The adjacency matrix for the above example graph is:</p>
            <p><img src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_matrix_representation.png"/></p>
            <p>Pros: Representation is easier to implement and follow. Removing an edge takes O(1) time. Queries like whether there is an edge from vertex ‘u’ to vertex ‘v’ are efficient and can be done O(1).</p>
            <p>Cons: Consumes more space O(V^2). Even if the graph is sparse(contains less number of edges), it consumes the same space. Adding a vertex is O(V^2) time.</p>
            <h3>Adjancency List</h3>
            <p>An array of linked lists is used. Size of the array is equal to number of vertices. Let the array be array[]. An entry array[i] represents the linked list of vertices adjacent to the ith vertex. This representation can also be used to represent a weighted graph. The weights of edges can be stored in nodes of linked lists. Following is adjacency list representation of the above graph.</p>
            <p><img src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation.png"/></p>
            <h3>More Info</h3>
            <p><a href="http://www.geeksforgeeks.org/data-structures/#AdvancedDataStructure">Geeks for Geeks</a></p>
        </div></li>
    <li><a id="advanced" class="code-item" onclick="codeItemClicked(this);">+</a>Advanced Data Structure
        <div class="in-detail">

        </div></li>
    <li><a id="array" class="code-item" onclick="codeItemClicked(this);">+</a>Array
        <div class="in-detail">
            <h3>Drawbacks</h3>
            <ul>Arrays can be used to store linear data of similar types, but arrays have following limitations.
                <li>The size of the arrays is fixed: So we must know the upper limit on the number of elements in advance. Also, generally, the allocated memory is equal to the upper limit irrespective of the usage.</li>
                <li>Inserting a new element in an array of elements is expensive, because room has to be created for the new elements and to create room existing elements have to shifted.</li>
                For example, in a system if we maintain a sorted list of IDs in an array id[].
                <br/>
                id[] = [1000, 1010, 1050, 2000, 2040].
                <br/>
                And if we want to insert a new ID 1005, then to maintain the sorted order, we have to move all the elements after 1000 (excluding 1000).
                <li>Deletion is also expensive with arrays until unless some special techniques are used. For example, to delete 1010 in id[], everything after 1010 has to be moved.</li>
                </ul>
        </div></li>
    <li><a id="matrix" class="code-item" onclick="codeItemClicked(this);">+</a>Matrix
        <div class="in-detail">

        </div></li>
</ul>
<span id="search-algorithms">Search Algorithms</span>
<ul class="code-list">
    <li><a id="bfs" class="code-item" onclick="codeItemClicked(this);">+</a>Breadth First Search (BFS)
        <div class="in-detail">
            <p>Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'[1]) and explores the neighbor nodes first, before moving to the next level neighbors.</p>
            <p>BFS was invented in the late 1950s by E. F. Moore, who used it to find the shortest path out of a maze,[2] and discovered independently by C. Y. Lee as a wire routing algorithm (published 1961)</p>
            <p><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Wikipedia</a></p>
        </div></li>
    <li><a id="dfs" class="code-item" onclick="codeItemClicked(this);">+</a>Depth First Search (DFS)
        <div class="in-detail">
            <p>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.</p>
            <p>A version of depth-first search was investigated in the 19th century by French mathematician Charles Pierre Trémaux[1] as a strategy for solving mazes.</p>
            <p><a href="https://en.wikipedia.org/wiki/Depth-first_search">Wikipedia</a></p>
        </div></li>
    <li><a id="linear" class="code-item" onclick="codeItemClicked(this);">+</a>Linear Search
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Simply iterate through the items of the array to find the element</p>
            <h3>Time Complexity</h3>
            <p>O(n)</p>
        </div></li>
    <li><a id="binary" class="code-item" onclick="codeItemClicked(this);">+</a>Binary Search
        <div class="in-detail">
            <h3>Overview</h3>
            <p>A Divide and Conquer algorithm - search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.</p>
            <h3>Time Complexity</h3>
            <p>T(n) = T(n/2) + c</p>
        </div></li>
    <li><a id="jump" class="code-item" onclick="codeItemClicked(this);">+</a>Jump Search
        <div class="in-detail">
            <h3>Overview</h3>
            <p>suppose we have an array arr[] of size n and block (to be jumped) size m. Then we search at the indexes arr[0], arr[m], arr[2m]…..arr[km] and so on. Once we find the interval (arr[km] &lt; x &lt; arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.</p>
            <h3>Time Complexity</h3>
            <p>O(√n)</p>
        </div></li>
    <li><a id="interpolation" class="code-item" onclick="codeItemClicked(this);">+</a>Interpolation Search
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Binary Search always goes to middle element to check. On the other hand interpolation search may go to different locations according the value of key being searched. For example if the value of key is closer to the last element, interpolation search is likely to start search toward the end side.</p>
            <h3>Time Complexity</h3>
            <p>If elements are uniformly distributed, then O (log log n)). In worst case it can take upto O(n).</p>
        </div></li>
    <li><a id="exponential" class="code-item" onclick="codeItemClicked(this);">+</a>Exponential Search
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Exponential search involves two steps:</p>
            <ol>
                <li>Find range where element is present</li>
                <li>Do Binary Search in above found range.</li>
            </ol>
            <p>How to find the range where element may be present?</p>
            <p>The idea is to start with subarray size 1 compare its last element with x, then try size 2, then 4 and so on until last element of a subarray is not greater.</p>
            <p>Once we find an index i (after repeated doubling of i), we know that the element must be present between i/2 and i </p></p>
            <h3>Time Complexity</h3>
            <p>O(Log n)</p>
        </div></li>
</ul>
<span id="sorting-algorithms">Sorting Algorithms</span>
<ul class="code-list">
    <li><a id="selection-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Selection Sort
        <div class="in-detail">
            <h3>Overview</h3>
            <p>The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array.</p>
            <ol>
                <li>The subarray which is already sorted.</li>
                <li>Remaining subarray which is unsorted.</li>
            </ol>
            <p>In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.</p>
            <h3>Time Complexity</h3>
            <p>O(n<span style="vertical-align: super;">2</span>)</p>
        </div></li>
    <li><a id="bubble-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Bubble Sort
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.</p>
            <p>Example:</p>
            <p>First Pass:</p>
            <p>( 5 1 4 2 8 ) –&gt; ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1.</p>
            <p>( 1 5 4 2 8 ) –&gt;  ( 1 4 5 2 8 ), Swap since 5 > 4</p>
            <p>( 1 4 5 2 8 ) –&gt;  ( 1 4 2 5 8 ), Swap since 5 > 2</p>
            <p>( 1 4 2 5 8 ) –&gt; ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.</p>
            <p>Second Pass:</p>
            <p>( 1 4 2 5 8 ) –&gt; ( 1 4 2 5 8 )</p>
            <p>( 1 4 2 5 8 ) –&gt; ( 1 2 4 5 8 ), Swap since 4 > 2</p>
            <p>( 1 2 4 5 8 ) –&gt; ( 1 2 4 5 8 )</p>
            <p>( 1 2 4 5 8 ) –&gt;  ( 1 2 4 5 8 )</p>
            <p>Now, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole pass without any swap to know it is sorted.</p>
            <p>Third Pass:</p>
            <p>( 1 2 4 5 8 ) –&gt; ( 1 2 4 5 8 )</p>
            <p>( 1 2 4 5 8 ) –&gt; ( 1 2 4 5 8 )</p>
            <p>( 1 2 4 5 8 ) –&gt; ( 1 2 4 5 8 )</p>
            <p>( 1 2 4 5 8 ) –&gt; ( 1 2 4 5 8 )</p>
            <h3>Time Complexity</h3>
            <p>O(n<span style="vertical-align: super;">2</span>)</p>
        </div></li>
    <li><a id="insertion-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Insertion Sort
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Finding the next element that is that is less than the element before it iterate backwards moving the elements one ahead until the element is in the right position</p>
            <p><img src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/insertion-sort.png"/></p>
            <h3>Time Complexity</h3>
            <p>O(n<span style="vertical-align: super;">2</span>)</p>
        </div></li>
    <li><a id="merge-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Merge Sort
        <div class="in-detail">
            <h3>Overview</h3>
            <p>A Divide and Conquer algorithm, It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves.</p>
            <p><img src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Merge-Sort.png"/></p>
            <h3>Time Complexity</h3>
            <p>O(n log n)</p>
        </div></li>
    <li><a id="heap-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Heap Sort
        <div class="in-detail">
            <h3>Overview</h3>
            <p>Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element.</p>
            <p>A sorting algorithm that works by first organizing the data to be sorted into a special type of binary tree called a heap. The heap itself has, by definition, the largest value at the top of the tree, so the heap sort algorithm must also reverse the order. It does this with the following steps:</p>
            <ol>
                <li>Remove the topmost item (the largest) and replace it with the rightmost leaf. The topmost item is stored in an array.</li>
                <li>Re-establish the heap.</li>
                <li>Repeat steps 1 and 2 until there are no more items left in the heap.</li>
            </ol>
            <p>The sorted elements are now stored in an array.</p>
            <p>A heap sort is especially efficient for data that is already stored in a binary tree. In most cases, however, the quick sort algorithm is more efficient.</p>
            <h3>Time Complexity</h3>
            <p>O(Logn)</p>
        </div></li>
    <li><a id="quick-sort" class="code-item" onclick="codeItemClicked(this);">+</a>QuickSort
        <div class="in-detail">
            <h3>Overview</h3>
            <p>QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.</p>
            <ol>
                <li>Always pick first element as pivot.</li>
                <li>Always pick last element as pivot (implemented below)</li>
                <li>Pick a random element as pivot.</li>
                <li>Pick median as pivot.</li>
            </ol>
            <p>The key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.</p>
            <h3>Time Complexity</h3>
            <p>O(n<span style="vertical-align: super;">2</span>)</p>
        </div></li>
    <li><a id="radix-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Radix Sort
        <div class="in-detail">

        </div></li>
    <li><a id="counting-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Counting Sort
        <div class="in-detail">

        </div></li>
    <li><a id="bucket-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Bucket Sort
        <div class="in-detail">

        </div></li>
    <li><a id="sheel-sort" class="code-item" onclick="codeItemClicked(this);">+</a>ShellSort
        <div class="in-detail">

        </div></li>
    <li><a id="comb-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Comb Sort
        <div class="in-detail">

        </div></li>
    <li><a id="pigeonhole-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Pigeonhole Sort
        <div class="in-detail">

        </div></li>
    <li><a id="cycle-sort" class="code-item" onclick="codeItemClicked(this);">+</a>Cycle Sort
        <div class="in-detail">

        </div></li>
</ul>
<span id="big-o">Big-O</span>
<ul class="code-list">
    <li><a id="time-complexity" class="code-item" onclick="codeItemClicked(this);">+</a>Time complexity
        <div class="in-detail">
            <p>the time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the string representing the input.[1]:226 The time complexity of an algorithm is commonly expressed using big O notation, which excludes coefficients and lower order terms. When expressed this way, the time complexity is said to be described asymptotically, i.e., as the input size goes to infinity.</p>
            <p><a href="https://en.wikipedia.org/wiki/Time_complexity">Wikipedia</a></p>
        </div></li>
    <li><a id="aymptotic" class="code-item" onclick="codeItemClicked(this);">+</a>Asymptotic
        <div class="in-detail">
            <p>Asymptotic Analysis - In computer science in the analysis of algorithms, considering the performance of algorithms when applied to very large input datasets</p>
        </div></li>
    <li><a id="big-o" class="code-item" onclick="codeItemClicked(this);">+</a>Big-O
        <div class="in-detail">
            <p>Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity.</p>
            <p>Big O is the worst case scenario - the worst time and space that an algorithm can take</p>
            <p>Big O notation is used to classify algorithms according to how their running time or space requirements grow as the input size grows.</p>
            <p>Big &Omega; (omega) - lower bound - best case</p>
            <p>Big &theta; (theta) - is the running time</p>
            <p>&Omega;(f(n)) &lt;= &theta;(f(n)) &lt;= O(f(n))</p>
        </div></li>
    <li><a id="np" class="code-item" onclick="codeItemClicked(this);">+</a>NP
        <div class="in-detail">
            <p>non-deterministic polynomial-time hard</p>
            <p><span style="font-weight:bold;">NP</span>: the set of all decision problems for which the instances where the answer is "yes" have efficiently verifiable proofs. More precisely, these proofs have to be verifiable by deterministic computations that can be performed in polynomial time</p>
            <p><span style="font-weight:bold;">deterministic</span>: a deterministic algorithm is an algorithm which, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states</p>
            <p><span style="font-weight:bold;">polynomial time</span>: An algorithm is said to be of polynomial time if its running time is upper bounded by a polynomial expression in the size of the input for the algorithm, i.e., T(n) = O(n<span style="vertical-align: super;">k</span>) for some constant k. <a href="https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time">Wikipedia</a></a>
            </p>
        </div></li>
    <li><a id="np-hardness" class="code-item" onclick="codeItemClicked(this);">+</a>NP-hardness
        <div class="in-detail">

        </div></li>
</ul>
<span id="programming">Programming</span>
<ul class="code-list">
    <li><a id="dynamic-programming" class="code-item" onclick="codeItemClicked(this);">+</a>Dynamic Programming
        <div class="in-detail">
            <p>Dynamic Programming refers to a very large class of algorithms. The idea is to break a large problem down (if possible) into incremental steps so that, at any given stage, optimal solutions are known to sub-problems.</p>
        </div></li>
    <li><a id="functional-programming" class="code-item" onclick="codeItemClicked(this);">+</a>Functional Programming
        <div class="in-detail">
            <p>a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.</p>
            <ul>
                <li>Common Lisp</li>
                <li>Scheme</li>
                <li>F#</li>
                <li>Haskell</li>
                <li>Clojure</li>
                <li>Elm</li>
            </ul>
        </div></li>
</ul>
<span id="bit-manipulation">Bit Manipulation</span>
<ul class="code-list">
    <li><a id="bm-not" class="code-item" onclick="codeItemClicked(this);">+</a>~ (Not)
        <div class="in-detail">
            <p>Bitwise NOT is an unary operator that flips the bits of the number i.e., if the ith bit is 0, it will change it to 1 and vice versa. Bitwise NOT is nothing but simply the one’s complement of a number. Lets take an example.</p>
            <p>N = 5 = (101)<sub>2</sub></p>
            <p>~N = ~5 = ~(101)<sub>2</sub> = (010)<sub>2</sub> = 2</p>
        </div>
    </li>
    <li><a id="bm-and" class="code-item" onclick="codeItemClicked(this);">+</a>&amp; (And)
        <div class="in-detail">
            <p>Bitwise AND is a binary operator that operates on two equal-length bit patterns. If both bits in the compared position of the bit patterns are 1, the bit in the resulting bit pattern is 1, otherwise 0.</p>
            <p>A = 5 = (101)<sub>2</sub> , B = 3 = (011)<sub>2</sub> A &amp; B = (101)<sub>2</sub> &amp; (011)<sub>2</sub>= (001)<sub>2</sub> = 1</p>
        </div>
    </li>
    <li><a id="bm-or" class="code-item" onclick="codeItemClicked(this);">+</a>| (Or)
        <div class="in-detail">
            <p>Bitwise OR is also a binary operator that operates on two equal-length bit patterns, similar to bitwise AND. If both bits in the compared position of the bit patterns are 0, the bit in the resulting bit pattern is 0, otherwise 1.</p>
            <p>A = 5 = (101)<sub>2</sub> , B = 3 = (011)<sub>2</sub></p>
            <p>A | B = (101)<sub>2</sub> | (011)2 = (111)<sub>2</sub> = 7</p>
        </div>
    </li>
    <li><a id="bm-xor" class="code-item" onclick="codeItemClicked(this);">+</a>^ (Xor)
        <div class="in-detail">
            <p>Bitwise XOR also takes two equal-length bit patterns. If both bits in the compared position of the bit patterns are 0 or 1, the bit in the resulting bit pattern is 0, otherwise 1.</p>
            <p>A = 5 = (101)<sub>2</sub> , B = 3 = (011)<sub>2</sub></p>
            <p>A ^ B = (101)<sub>2</sub> ^ (011)2 = (110)<sub>2</sub> = 6</p>
        </div>
    </li>
    <li><a id="bm-left-shift" class="code-item" onclick="codeItemClicked(this);">+</a>&lt;&lt; (Left Shift)
        <div class="in-detail">
            <p>Left shift operator is a binary operator which shift the some number of bits, in the given bit pattern, to the left and append 0 at the end. Left shift is equivalent to multiplying the bit pattern with 2k ( if we are shifting k bits ).</p>
            <p>1 << 1 = 2 = 2<sup>1</sup></p>
            <p>1 << 2 = 4 = 2<sup>2</sup> 1 << 3 = 8 = 2<sup>3</sup></p>
            <p>1 << 4 = 16 = 2<sup>4</sup> </p>
        </div>
    </li>
    <li><a id="bm-right-shift" class="code-item" onclick="codeItemClicked(this);">+</a>&gt;&gt; (Right Shift)
        <div class="in-detail">
            <p>Right shift operator is a binary operator which shift the some number of bits, in the given bit pattern, to the right and append 1 at the end. Right shift is equivalent to dividing the bit pattern with 2k ( if we are shifting k bits ).</p>
            <p>4 >> 1 = 2</p>
            <p>6 >> 1 = 3</p>
            <p>5 >> 1 = 2</p>
            <p>16 >> 4 = 1</p>
        </div>
    </li>
</ul>
<span id="design-patterns">Design Patterns</span>
<p><a href="https://en.wikipedia.org/wiki/Software_design_pattern">WikiPedia</a></p>
<ul class="code-list">
    <li><a id="singleton" class="code-item" onclick="codeItemClicked(this);">+</a>Singleton
        <div class="in-detail">
            <p>Ensure a class has only one instance, and provide a global point of access to it.</p>
        </div>
    </li>
    <li><a id="abstract-factory" class="code-item" onclick="codeItemClicked(this);">+</a>Abstract Factory
        <div class="in-detail">
            <p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p>
        </div>
    </li>
    <li><a id="factory" class="code-item" onclick="codeItemClicked(this);">+</a>Factory Method
        <div class="in-detail">
            <p>Define an interface for creating a single object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses (dependency injection)</p>
        </div>
    </li>
    <li><a id="injection" class="code-item" onclick="codeItemClicked(this);">+</a>Dependency Injection / Inversion of Control
        <div class="in-detail">
            <p>A dependency is an object that can be used (a service). An injection is the passing of a dependency to a dependent object (a client) that would use it. ... Dependency injection is one form of the broader technique of inversion of control.</p>
        </div>
    </li>
</ul>
<span id="misc">Misc</span>
<ul class="code-list">
    <li><a id="stack-v-heap" class="code-item" onclick="codeItemClicked(this);">+</a>Stack vs. Heap
        <div class="in-detail">
            <p>Stack is used for static memory allocation and Heap for dynamic memory allocation, both stored in the computer's RAM . Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and it's allocation is dealt with when the program is compiled.</p>
        </div>
    </li>
</ul>
<span id="good-sites">Good Sites</span>
<ul>
    <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms">Fundamentals of Algorithms</a></li>
    <li><a href="http://www.geeksforgeeks.org/data-structures/">Data Structures</a></li>
    <li><a href="http://bigocheatsheet.com/">Big-O Notation</a></li>
    <li><a href="https://www.hackerearth.com/practice/notes/bit-manipulation/">Bit Manipulation</a></li>
</ul>

